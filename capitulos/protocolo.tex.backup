\chapter{El protocolo}

\label{cap:protocolo}

En este capítulos detallamos los resultados de esta memoria. Primero diseñamos una funcionalidad ideal
y demostramos que es anónima y desmentible, posteriormente diseñamos un prototocolo que GUC-emula
a la funcionalidad ideal. Adicionalmente demostramos que el protocolo diseñado es anónimo y desmentible
solucionando el problema a resolver en este trabajo.

\section{Canales Anónimos Autentificados}
Un ``canal anónimo autentificado'' debe permitir a los participantes enviar mensajes a culquier otro participante
sin revelar su identidad mas que al destinatario de mensaje. Definimos formalmente un canal anónimo autentificado
a traves de la definición de una funcionalidad ideal que llamaremos $\mathcal{F}_{AAC}$ (figura \ref{func:F_AAC}).

\begin{figure}
\begin{centering}
\framebox{\begin{minipage}[t]{1\columnwidth}
La funcionalidad ideal $\mathcal{F}_{AAC}$ corriendo con participantes $P_1,\ldots,P_N$ y
adversario $\mathcal{S}$, parametrizada por un grupo $G_q$ y $n \in \mathbb{N}$ procede
como sigue:
\begin{enumerate}
    \item Inicializar$\Gamma \leftarrow \emptyset$, $M \leftarrow \emptyset$ y $k \leftarrow 0$.
    \item Si $(\tilde{P}_i, \mathtt{Send}, m_i, j)$ es recibido desde $\mathcal{C_I}$ y  mientras
          $k < n$:
    \begin{enumerate}
        \item Si $P_i$ o $P_j$ no estan registrados o $m_i \notin G_q$ enviar $(\tilde{P}_i, \perp)$
              a $\mathcal{C_I}$.
        \item Si $P_i$ o $P_j$ son corruptos enviar $(\mathcal{S}, \mathtt{Sign}, m_i, i, j)$ y hacer
              $k \leftarrow k + 1$.
        \item Si $P_i$ y $P_j$ son honestos entonces escojer $r \overset{R}{\leftarrow} G_q$,
              $\sigma_{i,j} \leftarrow \mathrm{MAC}_r(m)$, enviar $(\mathcal{S}, P_i, \mathtt{Send})$
              a $\mathcal{C_I}$ y hacer $\Gamma \leftarrow \Gamma \cup \{(m_i, i, j, \sigma_{i,j})\}$,
              $M \leftarrow M \cup \{(m_i, \sigma_{i,j})\}$ y $k \leftarrow k + 1$.
    \end{enumerate}
    \item Una vez que $k = n$, para cada $j \in \{1, \ldots, N\}$ sea el multiconjunto
          $M_j = \{(m_i, i)|,(m_i, i, j, \sigma_{i,j}) \in \Gamma\}$ y
          enviar $(\tilde{P}_j, \mathtt{Messages}, M_j)$ a $\mathcal{C_I}$ y
          $(\mathcal{S}, \mathtt{Messages}, \tilde{P}_j, M_j)$ a $\mathcal{C_I}$.
\end{enumerate}
\end{minipage}}
\end{centering}
\caption{La funcionalidad ideal $\mathcal{F}_{AAC}$}
\label{func:F_AAC}
\end{figure}

La funcionalidad de la figura \ref{func:F_AAC} es anónima segun la definición de anonimato descrita
en el capítulo \ref{sect:AC} demostrando el siguiente lema.

\begin{lema}
La funcionalidad $\mathcal{F}_{AAC}$ es Anónima para el enviador.
\label{lema:SA}
\end{lema}

\begin{proof}
\textit{(Lema \ref{lema:SA})}//
La demostración es directa notando que para cualquier par de matrices $M_1, M_2 \in \mathcal{R}_\cup$ las
vista del adversario son la misma. Por lo tanto para todo $\ell$
$$2\cdot\Pr[\mathrm{Exp}_{\pi, \mathcal{A}}^{\mathcal{R}-anon}(\ell) = 1] - 1 = 0$$
Y 0 es una función despreciable.
\end{proof}

Ahora demostramos que $\mathcal{F}_{CAA}$ es desmentible

\begin{lema}
La función $\mathcal{F}_{CAA}$ es desmentible.
\label{lema:den}
\end{lema}

\begin{proof}
\textit{(Lema \ref{lema:den})}\\
La demostración es simple notando que para las firmas honestas (donde tanto el emiso como el destinatario son
honestos) solo es necesario escojer $k_{i, j} \in_R G_q$, y cuando el emisor o el destinatario son deshonestos
las firmas pueden ser obtenidas con la clave publica del honesto y la clave privada del deshonesto. Usando
lo anterior el desinformante $\mathfrak{D}$ puede simular $\mathcal{F}_{AAC}$ y su simulación sigue la misma
distribución que una ejecución real de $\mathcal{F}_{AAC}$. Por lo tanto para cualquier informante $\mathfrak{I}$
es posible contruir un desinformante $\mathcal{D^I}$ que simula $\mathcal{F}_{AAC}$ para una simulación
del informante $\mathfrak{I}$. De este modo la vista del juez $\mathcal{J}$ es identica tanto en Real como
en Sim, lo que nos permite concluir. 
\end{proof}

\section{El protocolo SIGMIX}

Una primera forma ``natural'' de realizar $\mathcal{F}_{AAC}$ es simplemente combinando un canal anónimo
con un protocolo que GUC-realize la funcionalidad ideal $\mathcal{F}_{CERT}$ descrita en
\cite{conf/csfw/Canetti04}, pues esta es la funcionalidad ``clasica'' para autentificar mensajes.
Pero este intento falla pues la funcionalidad ideal $\mathcal{F}_{CERT}$ permite que cualquier participante
verifique la autenticidad de un par $(m, \sigma)$. Esto trae consigo la pérdida del anonimato al relacionar
publicamente la identidad del enviador de $m$ con $(m, \sigma)$. Ademas cada instancia de $\mathcal{F}_{CERT}$
esta restringida a solo dos participantes, por lo que por trivialmente se conoce la identidad del eviador y
receptor de cada mensaje.\\
En consecuencia, proveer anonimato y autentificación puede parecer contradictorio. Pero notamos
que dicha noción puede ser alcanzada por un protcolo que satisface los siguientes puntos:
\begin{enumerate}
    \item Los mensajes estan firmados.
    \item Solo el destinatario puede probar que el participante $P_i$ es autor de un mensaje que recibió.
    \item El destinarario no puede probar a nadie que $P_i$ es el autor de un mensaje que recibió.
    \item El envío de mensajes es hecho en forma anónima.
\end{enumerate}
De este modo, para implementar canales anónimos autentificados, usamos una versión modificada del protocolo de
autentificación desmentible GUC-seguro con resecto a aversarios estáticos de \cite{conf/tcc/DodisKSW09}. Notamos
que en \cite{conf/tcc/DodisKSW09} se usa un protocolo de firmado desmentible que nos es útil para satisfacer
los puntos 1, 2 y 4 mencionados anteriormente. El proceso de firma es hecho a traves de una
firma que depende no solo del contenido del mensaje y la identidad del enviador, si no que adicionalmente depende
en la identidad del destinatario. Así, solo le es permitido al receptor verificar la autenticidad del par
$(m, \sigma)$. El punto 4 es satifecho usando la mixnet propuesta por Wikstr\"om descrita en la figura
\ref{func:F_MN}.
El protocolo SIGMIX es ejecutado en el modelo $\mathcal{F}_{MN},\mathcal{F}_{BB},\bar{\mathcal{G}}_{KRK}$-híbrido
con adversarios estáticos. La funcionalidad compartida \textit{Key registration with knowledge}
$\bar{\mathcal{G}}_{KRK}$ de \cite{conf/tcc/DodisKSW09} descrita en la figura \ref{func:g_krk}
provee un PKI para cualquier prtocolo que es ejecutado concurrentemente con el protocolo SIGMIX. Remarcarmos
que cualquier protocolo que usa $\bar{\mathcal{G}}_{KRK}$ puede compartir el par clave pública y privada
$(sk,pk)$ con SIGMIX, siempre y cuando no revelen la clave privada a terceros.
Por otro lado consideramos a la funcionalidad $\mathcal{F}_{MN}$ como una funcionalidad ideal tradicional de UC,
esto significa que cada instancia de $\mathcal{F}_{MN}$ es local a cada protocolo que la llama. Del mismo modo
la funcionalidad ideal $\mathcal{F}_{BB}$ es local al protocolo y notamos además que puede ser UC-realizada
por un protocolo soubroutine respecting como el de \cite{asdasd}, y por lo tanto puede ser GUC-realizada por
dicho protocolo.
Para proceder con SIGMIX cada enviador $P_i$ firma un mensaje $m_i$ a $P_j$ con una función MAC que es
UF-CMA (sección \ref{uf-cma}). La clave con que MAC es usada es la clave secreta $k_{i,j}$ compartida
entre $P_i$ y $P_j$. La clave $k_{i,j}$ es calculada por $P_i$ y $P_j$ como sigue. Sean $G_q$ un grupo
cíclico de orden $q$ donde DDH se cumple, y sea $g$ un generador para $G_q$. Supongamos que $P_i$ y $P_j$ tienen
registrados los pares de claves publicas/privadas $(x_i, y_i=g^{x_i})$ y $(x_j, y_j=g^{x_j})$ respectivamente,
tales que $x_i, x_j \in_R G_q$. Entonces la clave secreta compartida $k_{i,j}$ puede ser no interactivamente
computada
\footnote{Es decir que puede se computada sin necesidad de intercambiar mensajes entre $P_i$ y $P_j$.}
por $P_i$ con $k_{i,j}=y_j^{x_i}$ y por $P_j$ con $k_{i,j}=y_i^{x_j}$. El mensaje firmado
$(m_i, \sigma_{i,j}=MAC_{k_{i,j}}(m_i)$ es enviado a $P_j$ usando la mixnet, y finalmente $P_j$ puede
chequear la autenticidad del mensaje recalculando la firma. El protocolo SIGMIX se encuetra descrito en
la figura \ref{SIGMIX}.\\
Adicionalmente los Mixers, que son parte de la interfaz de $\mathcal{F}_{MN}$, esperan a que llegue
el $n$-ésimo mensaje, con $n \in \mathbb{N}$ un parametro del protocolo, para avisar a $\mathcal{F}_{MN}$
que comienze el ``mezclado'' de mensajes.
\begin{figure}
\framebox{
\begin{minipage}[t]{1\columnwidth}
El protocolo SIGMIX corriedo con participantes $P_1,\ldots,P_N$ y Mixer $M_1, \ldots, M_k$ en el modelo
$\mathcal{F}_{MN}, \bar{\mathcal{G}}_{KRK}-hybrid, \mathcal{F}_{BB}$ y parametrizado
por un entero $n \in \mathbb{N}$:\\

%Registration. Each party $P_i$ registers as follows.
%\begin{enumerate}
%    \item Wait for input $(\mathtt{Register})$
%    \item Hand $(\mathtt{Retrieve}, P_i)$ to $\bar{\mathcal{G}}_{KRK}$ and let $(x_i, y_i)$
%          the answer.
%    \item If the answer was $(P_i, \perp)$ then let $x_i \overset{R}{\leftarrow} G_q$ and
%          $y_i \leftarrow g^{x_i}$. Hand $(\mathtt{register}, x_i)$ to $\bar{\mathcal{G}_{KRK}}$.
%\end{enumerate}

Enviador $P_i$. Cada enviador $P_i$ procede como sigue:
\begin{enumerate}
    \item Esperar a recibir la entrada $(\mathtt{Send}, P_j, m_{i,j})$.
    \item Enviar $(\mathtt{Retrieve}, P_j)$ a $\bar{\mathcal{G}}_{KRK}$ y sea $y_j$ la respuesta.
    \item Si la respuesta fue $\perp$ retornar $\perp$. De lo contrario calcular
          $k_{i,j} \leftarrow y_j^{x_i}$ y luego calcular $\sigma_{i,j} = \mathrm{MAC}_{k_{i,j}}(m_{i,j})$.
    \item Enviar $(\mathtt{Send}, m_{i,j}||\sigma_{i,j})$ a $\mathcal{F}_{MN}$ y enviar
          $(\mathtt{Write}, m_{i,j})$ a $\mathcal{F_{BB}}$.
    \item Retornar $(\mathtt{Sent}, P_j, m_{i,j})$
\end{enumerate}

Destinatario $P_j$. Cada destinatario $P_j$ procede como sigue:
\begin{enumerate}
    \item Esperar a recibir la entrada $(\mathtt{Output}, L)$ de $\mathcal{F}_{MN}$.
    \item Sean $y_1, \ldots, y_N$ las claves publicas de todos los participantes del protocolo.
          Para cada $i \in \{1, \ldots, N\}$ computar el secreto compartido
          $k_{ij} \leftarrow  y_{i}^{x_j}$.
    \item Sea el multiconjunto $M_j \leftarrow \emptyset$. Para cada $(m_l, \sigma_l) \in L$
          y para cada $k_{ij}$, si $\sigma_l = \mathrm{MAC}_{k_{ij}}(m_l)$ entonces
          $M_j \leftarrow M_j \uplus \{(m_l, l)\}$.
    \item Retornar $(\mathtt{Messages}, M_j)$.
\end{enumerate}

Mixer $M_i$. Cada Mixer $M_i$ procede como sigue:
\begin{enumerate}
    \item Inicializar $t = 0$.
    \item Cada vez que $(P_i, m_i)$ para algun $i\in \{1, \ldots, n'\}$ es escrito en
          $\mathcal{F}_{BB}$ hacer $t \leftarrow t+1$.
    \item Cuando $t = n$ enviar $(\mathtt{Run})$ a $\mathcal{F}_{MN}$.
\end{enumerate}

\end{minipage}}
\caption{El protocolo SIGMIX}
\label{SIGMIX}
\end{figure}

La seguridad del protcolo sigmix viene garantizada por el teorema \ref{teo:sigmix}.


\begin{lema} 
El protcolo SIGMIX GUC-emula a la funcionalidad ideal $\mathcal{F}_{AAC}$ en el modelo
$\mathcal{F}_{MN}, \mathcal{F}_{BB}, \bar{\mathcal{G}}_{KRK}$-híbrido con respecto a adversarios
estáticos que corrompen a lo mas $k/2 -1$ mixers.
\label{lema:sigmix}
\end{lema}

\begin{proof}
\textit{(Teorema \ref{lema:sigmix})}\\
La demostración procede de la siguiente forma. Para cada adversario real $\mathcal{A}$ contruimos
un adversario ideal $\mathcal{S^A}$ que ataca $\mathcal{F}_{AAC}$. Si existe un adversario
$\mathcal{A}$ y un ambiente $\mathcal{Z}$ que es capaz de distinguir
$\mathcal{H}(\mathcal{S},
             \tilde{\pi}^{\mathcal{F}_{AAC}},
             \tilde{\rho}^{\bar{\mathcal{G}}_{KRK}})$
de una ejecución de
$\mathcal{H}(\mathcal{A},
             \textrm{SIGMIX}, 
             \tilde{\rho}^{\bar{\mathcal{G}}_{KRK}},
             \tilde{\phi}^{\mathcal{F}_{MN}})$,
entonces podemos contradecir DDH sobre $G_q$ o la seguridad de MAC.
Sea $I_\mathcal{A} \subseteq \{1, \ldots , N \}$ el conjunto de índices de los participantes que
son corrompidos por $\mathcal{A}$. El adversario ideal $\mathcal{S^A}$ esta descrito en la figura
\ref{adv_S_A}, y simula una ejecución de SIGMIX solo con acceso a $\mathcal{F}_{AAC}$. Como los
valores de los mensajes enviados honestamentes (tanto el enviador como el destinatario son honestos)
permanecen desconocidos para $\mathcal{S^A}$ hasta que todos los mensajes son enviados, $\mathcal{S^A}$
engaña a la simulación interna de $\mathcal{A}$ haciendo que $\mathcal{F}_{MN}$ le diga a $\mathcal{A}$
que los mensajes fueron enviados siendo que esto no es realmente así. Finalmente, cuando el conjunto de
mensajes honestamente enviados le hes revelado a $\mathcal{S}$, hace que los participantes honestos
de SIGMIX envíen ``silenciosamente'' sus mensajes a $\mathcal{F}_{MN}$. Es es para $\mathcal{A}$ 
indistinguible de una ejecución donde un adversario \textbf{irreal} $\mathcal{S}'^{\mathcal{A}}$
adivina los mensajes enviados por $\mathcal{Z}$ a cada participante honesto, puesto que la vista
de $\mathcal{A}$ es la misma en ambos casos.\\
El adversario $\mathcal{S^A}$ corrompe a los mismo Mixers que $\mathcal{A}$ corrompe, que
corresponde a los Mixers $M_i$ $i \in I^M_\mathcal{A}$, y los simula
copiando la forma en que $\mathcal{A}$ los ejecuta. Los Mixers honestos son ejecutados
honestamente.\\

\begin{figure}
\framebox{\begin{minipage}[t]{1\columnwidth}
El adversario ideal $\mathcal{S^A}$ corriendo con participantes $\tilde{P}_1, \ldots, \tilde{P}_N$,
Mixers $\tilde{M}_1, \ldots, \tilde{M}_k$ y funcionalidades ideales $\bar{\mathcal{G}}_{KRK}$ y $\mathcal{F}_{BB}$
procede como sigue:\\

Inicialmente $\mathcal{S^A}$ corrompe a los participante $\tilde{P}_i$ $i \in I_\mathcal{A}$
y corrompe a los Mixers $\tilde{M}_i$ $i \in I^M_\mathcal{A}$. Adicionalmente ejecuta una
simulación de 
$\mathcal{Z}'(\mathcal{H}(\mathcal{A},
              \textrm{SIGMIX},
              \tilde{\pi}^{\bar{\mathcal{G}}_{KRK}}, 
              \tilde{\rho}^{\mathcal{F}_{MN}}))$,
donde $\mathcal{Z}'$ es una ITM controlada por $\mathcal{S^A}$, y
$\bar{\mathcal{G}}_{KRK}$, $\mathcal{F}_{BB}$ y $\mathcal{F}_{MN}$ son ejecutadas honestamente
con algunas modificaciones menores.\\

Simulación de links $(\mathcal{Z}', \mathcal{A})$ con $(\mathcal{Z}, \mathcal{S})$:\\
Si $m$ es recivido de $\mathcal{Z}$ entonces hacer que $\mathcal{Z}'$ envíe $m$ a $\mathcal{A}$.
Si $m$ es enviado de $\mathcal{A}$ a $\mathcal{Z}'$ entonces enviar $m$ a $\mathcal{Z}$\\

Simulaciónde participantes corruptos $\tilde{P}_i$ $i \in I_\mathcal{A}$:

\begin{enumerate}
\item Si $P_i$ $i \in I_\mathcal{A}$ envía $m||\sigma$ a $\mathcal{F}_{MN}$ y
      $\sigma = \textrm{MAC}_{y_j^{x_l}}(m)$ para alguna clave pública registrada $y_j$ $j \in \{1, \ldots, N\}$
      y alguna clave secreta registrada $x_l$ $l \in I_\mathcal{A}$, entonces enviar
      $(\mathtt{Send}, m, j)$ a $\tilde{P}_l$, esperar por $(\mathtt{Sign}, m, l, j)$ de $\mathcal{C_I}$ y
      enviar $(0, \mathtt{Signature}, m, l, j, \sigma)$ a $\mathcal{C_I}$. Si $\sigma \neq \textrm{MAC}_{y_j^{x_l}}(m)$
      para toda clave pública registrada $y_j$ $j \in \{1, \ldots, N\}$ y toda clave privada registrada $x_l$
      $l \in I_\mathcal{A}$ no hacer nada.
\item Si $P_i$ envía $(\mathtt{Register}, x_i)$ a la funcionalidad simulada $\bar{\mathcal{G}}_{KRK}$, entonces
      enviar $(\mathtt{Register}, x_i)$ a $\tilde{P}_i$.
\end{enumerate}

Simulació de participantes honestos $P_i$ $i \notin I_\mathcal{A}$:
\begin{enumerate}
    \item Sea $M'_j = \emptyset$ para $j = 1, \ldots, k$, $l_s \leftarrow 0$ y $l_r \leftarrow 0$.
    \item Si $(\tilde{P}_i, \mathtt{Send})$ es recibido de $\mathcal{C_I}$
          hacer que $\mathcal{Z}'$ envíe $(\mathtt{Register})$ a $P_i$ y hacer que $\mathcal{F}_{MN}$ envíe
          $(\mathcal{S}_{\mathcal{F}_{MN}}, \tilde{P}_i, \mathtt{Send})$ a su copia de $\mathcal{C_I}$.
    \item Si $(\mathtt{Sign}, m, i, j)$ es recivido de $\mathcal{C_I}$ recuperar $x_j$ e $y_i$ de
          $\bar{\mathcal{G}}_{KRK}$ (no la simulada). Sea $\sigma_{i,j} \leftarrow \mathrm{MAC}_{y_i^{x_j}}(m)$,
          hacer que $\mathcal{Z}'$ envíe $(\mathtt{Register})$ a $P_i$ y que luego envíe $(\mathtt{Send}, m, j)$ a
          $P_i$. Finalmente enviar $(0, \mathtt{Signature}, m, i, j, \sigma_{i,j})$ a $\mathcal{C_I}$
    \item Si $(\mathtt{Messages}, M)$ es recibido desde $\mathcal{C_I}$ entonces para cada $(m, \sigma) \in M$
          escojer $i, j \overset{R}{\leftarrow} \{1, \ldots, N\} \setminus I_\mathcal{A}$, hacer que $\mathcal{Z}'$
          envíe $(\mathtt{Send}, m, j)$ a $P_i$ y eliminar el mensaje $(\mathcal{S}, P_i, \mathtt{Send})$ que
          $\mathcal{F}_{MN}$ envía a su copia de $\mathcal{C_I}$ (similarmente $\mathcal{S^A}$ puede solo adjuntar
          $M$ a la lista $L$ de $\mathcal{F}_{MN}$).
\end{enumerate}
\end{minipage}}
\caption{El adversario ideal $\mathcal{S^A}$}
\label{adv_S_A}
\end{figure}

Definimos
$\mathrm{Real(\ell)} = \mathcal{Z}(
                    \mathcal{H}(
                        \mathcal{A},
                        \mathrm{SIGMIX},
                        \tilde{\rho}^{\bar{\mathcal{G}}_{KRK}},
                        \tilde{\phi}^{\mathcal{F}_{MN}}))$
y
$\mathrm{Ideal(\ell)} = \mathcal{Z}(
                    \mathcal{H}(
                        \mathcal{S^A},
                        \tilde{\pi}^{\mathcal{F}_{AAC}},
                        \tilde{\rho}^{\bar{\mathcal{G}}_{KRK}}))$, donde $\ell$ es el parámetro de seguridad
conque se ejecutan los grafos de ITMs.
Supongamos que existe un ambiente $\mathcal{Z}$, un adversario $\mathcal{A}$, un polimonio $p$ y entero
$\bar{\ell}$ talque para todo $\ell >  \bar{\ell}$ se tiene que:
\begin{equation}
\left|
%\begin{array}{c}
    \Pr[\mathrm{Real(\ell)} = 1]
    - \Pr[\mathrm{Ideal(\ell)} = 1]
%\end{array}
\right| \geq \frac{1}{p(\ell)}
\label{eq:guc}
\end{equation}
Entonces definimos en la figura \ref{adv:ddh} el adversario $\mathcal{D}_\textrm{DDH}$.

\begin{figure}
\framebox{\begin{minipage}[t]{1\columnwidth}
El adversario $\mathcal{D}_{DDH}(g^\alpha, g^\beta, g^\gamma)$ atacando DDH funciona como sigue:\\

\begin{enumerate}
    \item Simular
    $
        \mathcal{Z}(
        \mathcal{H}(
            \mathcal{A},
            \mathrm{SIGMIX},
            \tilde{\rho}^{\bar{\mathcal{G}}_{KRK}},
            \tilde{\phi}^{\mathcal{F}_{MN}}))
    $.
    \item Escojer $r_i, r_j \overset{R}{\leftarrow} G_q$ para $i,j \in \{1, \ldots, N\}\setminus I_\mathcal{A}$,
          cuando $\tilde{P}_i$ se registra en $\bar{\mathcal{G}}_{KRK}$ setera la clave pública registrada a
          $g^{\alpha r_i}$ y cuando $\tilde{P}_j$ se registra setear la clave pública a $g^{\beta r_j}$.
    \item Cuando $\mathcal{Z}$ envía $(\mathtt{Send}, m, j)$ a $P_i$ reemplazar la firma computada por $P_i$
          por $\mathrm{MAC}_{g^{\gamma r_i r_j}}(m)$ para cada $j \notin I_\mathcal{A}$ y
          $\mathrm{MAC}_{g^{\gamma r_i x_j}}(m)$ para cada $j \in I_\mathcal{A}$.
    \item Cuando $P_i$ $i \notin I_\mathcal{A}$ recibe $(\mathtt{Output}, L)$ desde $\mathcal{F}_{MN}$ computar
          cada firma con $\mathrm{MAC}_{g^{\gamma r_i r_j}}(m)$ para cada $j \notin I_\mathcal{A}$ y con
          $\mathrm{MAC}_{g^{\gamma r_i x_j}}(m)$ para cada $j \in I_\mathcal{A}$.
    \item Cuando la simulación se detenga retornar lo que $\mathcal{Z}$ tenga en su cinta de salida.
\end{enumerate}
\end{minipage}}
\caption{El adversario para DDH sobre $G_q$ $\mathcal{D}_\textrm{DDH}$}
\label{adv:ddh}
\end{figure}

Notemos que como en el experimento $\alpha \in_{R} G_q$ y $\beta \in_{R} G_q$, entonces es indistinguible para
el ambiente las modificaciones echas por $\mathcal{D}_{DDH}$. Luego
\begin{equation}
\Pr[\mathrm{Real} = 1] = \Pr[\mathcal{D}_{DDH} = 1|\gamma = \alpha\beta]
\label{eq:ddh_1}
\end{equation}\\
Ahora, la única posible diferencia entre ejecutar $\mathcal{D}_{DDH}$ cuando $\gamma \in_R G_q$ y ejecutar
$
\mathcal{Z}(
    \mathcal{H}(
        \mathcal{S^A},
        \tilde{\pi}^{\mathcal{F}_{AAC}},
        \tilde{\rho}^{\bar{\mathcal{G}}_{KRK}}))
$
es la salida de los participantes honestos. Pero si existe un participante honesto con índice $j$ talque
$M_j^\mathrm{Real} \neq M_j^\mathrm{Ideal}$, entonces exite un par $(m, l) \in M_j^\mathrm{Real}$. Y se debe
tener que $(m, l) \notin M_j^\mathrm{Ideal}$ porque los mismo mensajes son enviados en Real e Ideal, a excepción
de aquellos mensajes eliminados por $\mathcal{S^A}$ en el paso 1 de la simulación de participantes corruptos.
Lo anterior significa que el adversario ha creado una firma $\sigma \neq \mathrm{MAC}_{y_i^{x_l}}(m)$ para
todo $l \in I_\mathcal{A}$, y como fue aceptada por $P_j$ se debe cumplir que
$\sigma = \mathrm{MAC}_{g^{\gamma r_i r_j}}(m)$ para algún $i \notin I_\mathcal{A}$. Esto contradice
que MAC es UF-CMA, luego:
\begin{equation}
\Pr[\mathrm{Ideal} = 1] \approx \Pr[\mathcal{D}_{DDH} = 1|\gamma \in_R G_q]
\label{eq:ddh_2}
\end{equation}
Reemplazando las ecuaciones \ref{eq:ddh_1} y \ref{eq:ddh_2} en \ref{eq:guc} contradecimos que DDH se cumple en $G_q$.
Por lo tanto el teorema se tiene.
\end{proof}

\begin{teorema}
El protocolo SIGMIX GUC-emula a la funcionalidad $\mathcal{F}_{AAC}$ en el modo $\mathcal{F}_{KG},
\bar{\mathcal{G}}_KRK$
\label{teo:sigmix}
\end{teorema}

\begin{proof}
\textit{(Teorema \ref{teo:sigmix})}\\
Trivial usando el lema \ref{lema:sigmix}, el teorema \ref{teo:mn} y el teorema de composición (teorema
\ref{teo:composicion})
\end{proof}

\begin{teorema}
El protocolo SIGMIX es anónimo para el destinatario.
\label{teo:anon}
\end{teorema}

\begin{proof}
\textit{(Teorema \ref{teo:anon})}\\
Idea. Usar el adversario $\mathcal{A}_{Anon}$ para que $\mathcal{Z}$ testee si esta con SIGMIX o $\mathcal{F}_{CAA}$
\end{proof}

\begin{teorema}
El protocolo SIGMIX es desmentible.
\label{teo:den}
\end{teorema}

\begin{proof}
\textit{(Teorema \ref{teo:den})}\\
Idea. Def de den es transformación sintática de UC.
\end{proof}
